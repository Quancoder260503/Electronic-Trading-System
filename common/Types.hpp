#pragma once
#include <cstdint>
#include <limits>
#include <sstream>
#include <array> 

#include "common/Macros.hpp"

namespace Common {
typedef uint64_t OrderID;
typedef uint32_t TickerID;
typedef uint32_t ClientID;
typedef int64_t Price;
typedef uint32_t Quantity;
typedef uint64_t Priority;

enum class Side : int8_t { INVALID = 0, BUY = 1, SELL = -1, MAX = 2};

constexpr size_t LOG_QUEUE_SIZE =
    8 * 1024 * 1024;  // max_size of lock free queue
constexpr size_t MATCHING_ENGINE_MAX_TICKERS =
    8;  // number of trading instruments at exchange supports
constexpr size_t MATCHING_ENGINE_MAX_CLIENT_UPDATES =
    256 * 1024;  // max number of unprocessed order requests from all clients
                 // that has not been processed
constexpr size_t MATCHING_ENGINE_MAX_MARKET_UPDATES =
    256 *
    1024;  // max number of unproceessed update generated by the matching engine
constexpr size_t MATCHING_ENGINE_MAX_NUM_CLIENTS =
    256;  // max number of clients exists in the trading ecosystem
constexpr size_t MATCHING_ENGINE_MAX_ORDER_IDS =
    1024 * 1024;  // maxmimum number of processed orders possible for a single
                  // trading arguments
constexpr size_t MATCHING_ENGINE_MAX_PRICE_LEVELS =
    256;  // represent the maxmimum depth of price levels for limit order book
          // that the matching engine maintains

constexpr auto ORDER_ID_INVALID = std::numeric_limits<OrderID>::max();
constexpr auto TICKER_ID_INVALID = std::numeric_limits<TickerID>::max();
constexpr auto CLIENT_ID_INVALID = std::numeric_limits<ClientID>::max();
constexpr auto PRICE_INVALID = std::numeric_limits<Price>::max();
constexpr auto QUANTITY_INVALID = std::numeric_limits<Quantity>::max();
constexpr auto PRIORITY_INVALID = std::numeric_limits<Priority>::max();

inline auto orderIdToString(OrderID order_id) -> std::string {
  if (UNLIKELY(order_id == ORDER_ID_INVALID)) { return "INVALID"; }
  return std::to_string(order_id);
}

inline auto tickerIdToString(TickerID ticker_id) -> std::string {
  if (UNLIKELY(ticker_id == TICKER_ID_INVALID)) { return "INVALID"; }
  return std::to_string(ticker_id);
}

inline auto clientIdToString(ClientID client_id) -> std::string {
  if (UNLIKELY(client_id == CLIENT_ID_INVALID)) { return "INVALID"; }
  return std::to_string(client_id);
}

inline auto priceToString(Price price) -> std::string {
  if (UNLIKELY(price == PRICE_INVALID)) { return "INVALID"; }
  return std::to_string(price);
}

inline auto quantityToString(Quantity quantity) -> std::string {
  if (UNLIKELY(quantity == QUANTITY_INVALID)) { return "INVALID"; }
  return std::to_string(quantity);
}

inline auto priorityToString(Priority priority) -> std::string {
  if (UNLIKELY(priority == PRIORITY_INVALID)) { return "INVALID"; }
  return std::to_string(priority);
}

inline constexpr auto sideToIndex(Side side) noexcept -> size_t { 
  return static_cast<size_t>(side) + 1; 
}

inline constexpr auto sideToValue(Side side) noexcept -> int { 
  return static_cast<int>(side); 
}

inline auto sideToString(Side side) -> std::string {
  switch (side) {
  case Side::BUY:
    return "BUY";
  case Side::SELL:
    return "SELL";
  case Side::INVALID:
    return "INVALID";
  case Side::MAX : 
    return "MAX"; 
  }
  return "UNKNOWN";
}

struct RiskConfig { 
  // maximum order size that a strategy is allowed to send 
  Quantity max_order_size = 0; 
  // maximum position that a strategy is allowed to build 
  Quantity max_position = 0; 
  // maximum allowed loss before the trading strategy is shutoff from trading further
  double max_loss = 0; 
  auto toString() const { 
    std::stringstream ss;
    ss << "RiskCfg{"
         << "max-order-size:" << quantityToString(max_order_size) << " "
         << "max-position:"  << quantityToString(max_position)    << " "
         << "max-loss:" << max_loss << "}";
    return ss.str(); 
  }
};

struct TradeEngineConfig { 
  // What the trading strategies will use as the quantity for the order that they send out 
  Quantity clip = 0; 
  //Used by trading strategies to determine whether to send an order or not 
  double threshold = 0; 
  RiskConfig risk_config; 
  auto toString() const { 
    std::stringstream ss;
    ss << "TradeEngineCfg{"
         << "clip:" << quantityToString(clip) << " "
         << "thresh:" << threshold << " "
         << "risk:" << risk_config.toString()
         << "}";
    return ss.str();
  } 
}; 

typedef std::array<TradeEngineConfig, MATCHING_ENGINE_MAX_TICKERS> TradeEngineConfigHashMap; 

enum class AlgoType : int8_t { 
 INVALID = 0, 
 RANDOM = 1, 
 MAKER  = 2, 
 TAKER  = 3, 
 MAX    = 4 
}; 

inline auto algoTypeToString(AlgoType type) -> std::string { 
  switch (type) { 
    case AlgoType::INVALID : 
      return "INVALID"; 
    case AlgoType::RANDOM : 
      return "RANDOM"; 
    case AlgoType::MAKER : 
      return "MAKER"; 
    case AlgoType::TAKER : 
      return "TAKER"; 
    case AlgoType::MAX : 
      return "MAX"; 
  }
  return "UNKNOWN";
}

inline auto stringToAlgoType(const std::string &str) -> AlgoType { 
  for(auto i = static_cast<int>(AlgoType::INVALID); i <= static_cast<int>(AlgoType::MAX); i++) { 
    const auto algo_type = static_cast<AlgoType>(i); 
    if(algoTypeToString(algo_type) == str) { 
      return algo_type; 
    }
  }
  return AlgoType::INVALID; 
}
}  // namespace Common