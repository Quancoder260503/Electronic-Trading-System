#pragma once
#include <cstdint>
#include <limits>

#include "common/Macros.hpp"

namespace Common {
typedef uint64_t OrderID;
typedef uint32_t TickerID;
typedef uint32_t ClientID;
typedef int64_t Price;
typedef uint32_t Quantity;
typedef uint64_t Priority;

enum class Side : int8_t { INVALID = 0, BUY = 1, SELL = -1 };

constexpr size_t LOG_QUEUE_SIZE = 8 * 1024 * 1024;  // max_size of lock free queue
constexpr size_t MATCHING_ENGINE_MAX_TICKERS =
    8;  // number of trading instruments at exchange supports
constexpr size_t MATCHING_ENGINE_MAX_CLIENT_UPDATES =
    256 *
    1024;  // max number of unprocessed order requests from all clients that has not been processed
constexpr size_t MATCHING_ENGINE_MAX_MARKET_UPDATES =
    256 * 1024;  // max number of unproceessed update generated by the matching engine
constexpr size_t MATCHING_ENGINE_MAX_NUM_CLIENTS =
    256;  // max number of clients exists in the trading ecosystem
constexpr size_t MATCHING_ENGINE_MAX_ORDER_IDS =
    1024 * 1024;  // maxmimum number of processed orders possible for a single trading arguments
constexpr size_t MATCHING_ENGINE_MAX_PRICE_LEVELs =
    256;  // represent the maxmimum depth of price levels forr limit order book that the matching
          // engine maintains

constexpr auto ORDER_ID_INVALID = std::numeric_limits<OrderID>::max();
constexpr auto TICKER_ID_INVALID = std::numeric_limits<TickerID>::max();
constexpr auto CLIENT_ID_INVALID = std::numeric_limits<ClientID>::max();
constexpr auto PRICE_INVALID = std::numeric_limits<Price>::max();
constexpr auto QUANTITY_INVALID = std::numeric_limits<Quantity>::max();
constexpr auto PRIORITY_INVALID = std::numeric_limits<Priority>::max();

inline auto orderIdToString(OrderId order_id) -> std::string {
  if (UNLIKELY(order_id == ORDER_ID_INVALID)) {
    return "INVALID";
  }
  return std::to_string(order_id);
}

inline auto tickerIdToString(TickerID ticker_id) -> std::string {
  if (UNLIKELY(ticker_id == TICKER_ID_INVALIUD)) {
    return "INVALID";
  }
  return std::to_string(ticker_id);
}

inline auto clientIdToString(ClientID client_id) -> std::string {
  if (UNLIKELY(client_id == CLIENT_ID_INVALID)) {
    return "INVALID";
  }
  return std::to_string(client_id);
}

inline auto priceToString(Price price) -> std::string {
  if (UNLIKELY(price == PRICE_INVALID)) {
    return "INVALID";
  }
  return std::to_string(price);
}

inline auto quantityToString(Quantity quantity) -> std::string {
  if (UNLIKELY(quantity == QUANTITY_INVALID)) {
    return "INVALID";
  }
  return std::to_string(quantity);
}

inline auto priorityToString(Priority priority) -> std::string {
  if (UNLIKELY(priority == PRIORITY_INVALID)) {
    return "INVALID";
  }
  return std::to_string(priority);
}

inline auto sideToString(Side side) -> std::string {
  switch (side) {
    case Side::BUY:
      return "BUY";
    case Side::SELL:
      return "SELL";
    case Side::INVALID:
      return "INVALID";
  }
  return "UNKNOWN";
}
}  // namespace Common